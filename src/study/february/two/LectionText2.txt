27.02.2014
Программирование по контракту, Тройки Хоара.
Мы определяем предусловие и постусловие -- то, что мы должны давать функции и что нам функция гарантирует с ее стороны.
Предусловие и постусловие -- это и есть контракт. Уберем контракт и ничего не изменится.
Ну для корня будет например
pre: x >=0;
post: r^2 = x, r>=0;

Или вот функция сортировки:
int[] sort(int[] a)
Pre: -
Post: r.length = a.length, "мультимножество членов a равно мультимножеству членов r"

Рассказывает про assertion, assert (); Якобы запускать с помощью -ca.
Когда-то Хоарт предложил собирать условия в типе <p1, s1, q1> -- это короче и есть тройка Коара;
<p1, s1, q1>
<p2, s2, q2> -- выполнимы вместе, если q2 => p2
<p0,
    | <p1, s1, q1>
    | <p2, s2, q2>,
q0>, тогда p0 = p1; q0 = q2;

А вот насчет ветвления
<p
    if(c)
        <p1, s1, q1>
    else
        <p2, s2, q2>
q>
Можно сказать следующее:
q1 => q
q2 => q
Значит  q1 | q2 => q.
Заметим, что такая же фигня не работает с p, p1, p2
Но верно то,
p & c => p1;
p & !c => p2

А вот функция abs будет иметь постусловие // x >=0 (более того, x = |x|)
if (x < 0)
<x < 0; x = -x; x > 0>
//x >=0

Ну и не мешало бы посмотреть на циклы (цикла while хватит для всех наших нужд):
    <p,
        while (c) <p', s', q'>,
    I & C => p'
    q' => I
    I & !c => q

Рассказывает теперь gро чистые функции, которые возвращают на одном наборе одни и те же данные (зависят от своих аргументов)
Также существуют нечистые функции типа increment в study.february.two.Lection


Домашнее задание.
1. Реализавать итеративный и рекурсивный бинпоиск в массиве
2. На вход подается целое число x и массив целых чисел a, требуется найти максимальное значение индекса i,
при котором x >= a[i]
3. Для функций бинпоика и вспомагательных функций должны быть указаны пред- и постусловия. Для циклов инварианты.
4. Интерфейс программиы:
    Имя основного класса -- BinarySearch
    Первый аргумент командной строки -- целое число x
    Последующие аргументы командной строки -- элементы массива a
